# 派号器

派号器服务用于给分布式应用分配全局唯一甚至连续递增的序号。我们从比较简单容易理解的派号器开始进入分布式系统。

## 简单的全局唯一派号器

派号器是一个单服务，本地维护一个序号量并且持久化，串行处理分布式应用的序号请求，每接收到一个序号请求，将本地维护的序号量递增并持久化，同时返回该序号量作为请求结果。

优点：
1. 实现简单，性能也会比较高

缺点：
1. 单点问题，不能容错，一旦单服务宕机，服务就不可用
2. 可以保证全局唯一但不保证连续递增，在派号器服务持久化本地序号量之后出现宕机，该序号无法分配给应用，或者在应用发出序号请求后宕机，该序号也无法分配给应用

那能不能做到连续递增呢？

## 连续递增派号器

每个分布式应用都配置有全局唯一的id，本地维护有自己获取到的最新序号量，派号器是单服务，除了本地维护有一个序号量并且持久化外，还维护有最新分配给应用的序号量并且持久化。应用向派号器请求序号需要附带自己的最新序号量，同样，发送给派号器的请求照样被派号器串行处理，首先检查请求中的最新序号量，如果最新序号量已经是派号器维护的应用的最新序号量，则递增序号量，并且分配给对应的应用，并且原子的持久化序号量和应用分配序号量，返回序号量。如果最新序号量不是派号器维护的应用的最新序号量，则返回派号器维护的应用的最新序号量。

优点：
1. 实现简单，性能会比较高
2. 保证全局唯一同时连续递增

缺点：
1. 单点问题，不能容错，一旦派号器服务宕机，服务不可用

## 有可靠服务的派号器实现

如果有可靠的数据库服务mysql，则通过sql以及事务来实现派号器。

在mysql的表中记录全局序号量以及每个应用对应的最新序号量，同样，每个应用维护自己的最新序号量。

分布式应用需要请求序号时，事务性的执行如下sql：
app_id为0的为全局序号量
```
select sequence_number from sequence_table where app_id = <app id>
if sequence_number > <request_number>
    return sequence_number
else
    update sequence_table set sequence_number = sequence_number + 1 where app_id = 0
    update sequence_table set sequence_number = (select sequence_number from sequence_table where app_id = 0) where app_id = <app_id>
    return sequence_number
```

## 集群投票的派号器实现

集群各个节点维护一个序号n，这个序号n是当前节点看到的最大序号。并且节点保证：在收到任何比n大的序号投票时，则投赞成票，更新自己维护的n为投票的序号，否则投反对票。

如果应用需要请求序号，则可以观察集群中各个节点的序号，取可以观察到的最大的序号，并且+1，然后请求集群中所有节点投票，如果该应用收到大于1/2的赞成票，则认为成功分配到序号，否则重新尝试整个流程。

优点：
1. 非单点，可以容错


缺点：
1. 需要收集投票，集群各节点投票独立，性能远远不如单点服务

