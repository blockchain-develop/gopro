# 协程

## 什么是协程

协程(coroutine)通常也叫用户态线程，关于coroutine术语的解释最初发表在论文http://melconway.com/Home/pdf/compiler.pdf。在wiki上，可以找到各种语言实现的协程库程序。这篇文章主要讲明白为什么会有协程，协程工作原理以及关于协程问题的探讨。

首先大家需要明白用户态和内核态以及其工作原理，这是理解这篇文章的基础，在这里不再介绍，大家可以很容易找到许多资料。

再彻底搞明白协程之前，我们从线程切换开始，当然这里说的线程是操作系统的线程，线程是操作系统调度的单元，有自己的用户态栈和内核态栈、运行上下文，那么线程什么情况下会发生线程切换呢？
1. 等待资源而挂起自己，切换到其他线程，这是非抢占式的切换，就是主动让出cpu，或者称为自发性上下文切换。
2. 如果cpu时间片用完或者存在优先级更高的线程，时钟中断程序将正在运行的线程切换到其他线程，强行剥夺其cpu使用权，调度一个新线程让其获得cpu，从而新线程可以被运行，这是抢占式的切换，强行剥夺cpu，或者称为非自发性上下文切换。

线程切换的具体流程如下：
1. 从用户态切换到内核态
2. 保存自己的运行上下文
3. 运行调度算法选择下一个线程(这时候还是运行在当前线程的上下文中，但是处于内核态，可以思考一下为什么没有问题)
4. 恢复下一个线程的运行上下文(这时可能导致整个地址空间的切换)

从线程切换流程可以看看线程切换的代价：
1. 用户态内核态的切换
2. 调度算法(当前linux系统的调度算法时间复杂度为O(1)，效率很高，这个花销很低)
3. 上下文切换花销(这个花销很低)
4. 缓存失效

如果当前线程正处于内核态，进行线程切换就没有用户态内核态的切换。

线程切换很大的花销在用户态内核态的切换上，既然切换开销这么大，大胆想一想，为什么线程在用户态不直接做线程切换呢？当然这个问题有点傻，系统上运行的所有线程数据都由操作系统维护，那意味着只有在内核态才可以访问这些数据，如果处于用户态，当前线程处于自己的上下文，根本没法访问线程数据，更不要说运行调度算法选择下一个线程了。如果能直接访问线程数据，那么操作系统又有何用呢？

由于线程数据由操作系统维护，线程切换时需要到内核态访问线程数据来执行切换。再大胆想一想，如果线程数据不由操作系统维护，而由应用程序自己维护呢？这样线程切换就不需要到内核态了。

这就是用户态线程或者协程。

## 协程和线程

和线程一样，协程也有自己的栈和运行上下文。很明显，协程并不是操作系统调度的单元，操作系统调度的仍然是线程，协程是在线程的上下文中运行，协程可以访问线程的地址空间，也就是该进程的地址空间。

协程切换在线程中运行，线程也有被操作系统切换。在思考协程的一些设计原理时还需要考虑线程的切换。

协程的切换流程如下:
1. 保存当前协程的运行上下文
2. 运行调度算法选择下一个协程
3. 恢复下一个线程的运行上下文

协程切换并没有切换地址空间，切换前后两个协程是在同一个地址空间中运行，也就没有缓存失效的问题。那是不是协程就比线程效率高呢？如果单纯看协程和线程切换，毫无疑问，协程花销要小很多，效率高。但实际情况是你的应用程序的线程是确定的(是否在应用层使用协程又影响到你应用程序的线程策略，我们暂且认为线程确定)，只是在应用程序层是否要使用协程，好了，直觉告诉我们，不使用协程效率更高，因为使用协程多了协程开销，无论多少，效率肯定比无协程低。这种直觉好像又不对，如果在应用程序中使用了协程，那么很多由于资源等待导致的挂起不会引起线程级别的切换，只是协程级别的切换，使用协程的应用程序可以减少线程的切换次数，效率比无协程应用程序要高。在深入想想，由于资源竞争而导致无协程应用程序存在更多的线程切换是不成立的，因为这是应用程序设计问题，协程应用程序可以避免的线程切换，无协程应用程序照样可以避免，这是应用层设计要复杂些而已。这样看，貌似无协程应用程序效率更高，到了这一步再深究已经没有意义了。

举例来说明上面的表述：

在性能瓶颈位于cpu且主要是cpu任务时：
+ 如果cpu是一个核，系统采用多线程设计完全没有必要，还增加了切换开销。线程应用程序单线程运行，而协程应用程序使用多个协程来运行，都是把cpu跑慢，多协程性能又高在哪里呢？
+ 如果cpu是多个核，比如4核，线程应用程序使用4线程，协程应用程序使用多个协程，最终都是在4核cpu上运行程序，这样看，多协程应用程序性能照样不会比线程应用程序高。

结论：在性能瓶颈位于cpu且主要是cpu任务时，协程并不能带来应用程序性能的提升。

在系统中存在许多资源竞争时(这也是最常见的)：
+ 线程应用程序使用多线程，当竞争资源时挂起本线程，os会切换到其他线程继续处理任务，这也是为什么应用程序要多线程的原因，也是为什么多线程性能要比单线程高的原因，也是开发中最常见的做法。
+ 协程应用程序使用多协程，当然底层还是多线程了。在多协程应用程序中，遇到资源竞争时，挂起本协程，切换到下一个协程继续处理任务，这可以在没有线程切换的情况下完成，系统中由于资源竞争也不会引起线程挂起，这也是协程应用程序性能比多线程应用程序性能高的原因。

从上面也可以看到，多线程性能比单线程高主要有两个原因：
+ 多线程可以使用cpu的多个核进行并行运行
+ 多线程应用程序在资源竞争时可以切换到其他线程继续处理任务

协程应用程序比多线程应用程序性能高主要原因：
+ 很多时候协程应用程序在资源竞争时不会引起线程切换，本线程不会挂起而是可以继续处理其他协程的任务，而多线程应用程序在资源竞争时会挂起线程而切换其他线程继续处理任务，导致多线程应用程序存在更多的线程切换

多线程应用程序在资源竞争时存在线程切换，这是个伪结论，如果系统中使用异步机制，照样可以减少线程切换，由于资源竞争而导致多线程应用程序存在更多的线程切换是不成立的，这是应用程序设计问题，协程应用程序可以避免的线程切换，线程应用程序照样可以避免，这是应用层设计要复杂些而已。

结论：
+ 协程并不能给应用程序带来性能上的提高，但它确实提高了高性能应用程序的开发效率
+ 协程并发性能高，协程应用程序性能高不成立
+ 单纯比较协程和线程切换效率是没有意义的

回头来看，比较协程应用程序和无协程应用程序的效率是徒劳的，单纯比较协程和线程效率是无意义的。使用协程并不能提高应用程序的性能，但使用协程确实大大提高了并发编程的效率。在没有协程的应用程序中，并发网络请求时，需要设计异步机制来实现并发，而有了协程，可以使用多个协程来实现并发，网络请求通过简单的同步机制就可以完成。这才是协程的魅力。

## 协程调度

协程的切换是线程来完成的，协程在什么情况下会切换呢？
1. 协程等待资源而挂起自己，调度下一个协程运行，这是非抢占式调度，和线程类似，如等待timer、等待io、等待竞争资源......
2. 协程有没有抢占式调度呢？如果有抢占式调度，谁来中断当前正在运行的协程从而进行调度呢？我们知道在线程的抢占式调度中，这个是cpu时钟中断来完成的。

对于非抢占式调度，很容易理解，不再解释，下面重点探讨协程的抢占式调度。

运行当前协程的线程在协程主动让出线程时可以执行协程切换，这是非抢占式调度，那么如果没有协程主动让出线程呢，该如何照样切换协程呢？

第一个方案，在所有的函数调用处，执行一次协程时间片检查，如果时间片用完，则执行协程切换，这本质上也是非抢占式调度，需要编译器支持在所有的函数调用处插入协程时间片检查程序。每个函数调用处都执行协程时间片检查的代价非常高。

第二个方案，在协程的栈上增加一个标记位stackguard，同时存在一个独立的线程sysmon，sysmon会检查协程的时间片，如果时间片用完，则将栈的stackguard标记为StackPreempt，当协程发生函数调用时，会检查栈的stackguard标记，如果为StackPreempt则执行协程调度。这是伪抢占式调度，本质上调度还是在当前协程中完成，当前协程主动放弃线程执行切换。

第三个方案，在第二个方案中，如果协程没有函数调用，那么这个协程会一直占用当前的线程，即使时间片用完，也无法协程切换。我们想一想线程如何实现抢占式的？对的，时钟中断导致cpu直接去运行中断程序，我们可以切换线程。那么有没有机制可以导致当前线程直接去跳转运行另一个程序，这样我们就可以在这个程序中切换协程。有的，那就是用于处理异步事件的信号。

信号可以中断当前程序进而跳转执行信号处理程序，在信号处理程序中，如果当前协程时间片用完，则执行协程切换，厉害的抢占式调度就完成了。

信号方案有明显的缺陷：
1. 信号方案的协程切换只有在线程切换发生时才会触发，一次信号触发的协程切换都有一次线程的切换
2. 信号方案的代价明显要大一些

第三个方案虽然功能强大，但效率不高，他退化为了线程切换来完成协程切换，实际情况比线程切换代价还要大一些。在系统中单一使用第三个方案是不可取的，往往是和第二个方案一起使用，系统中一部分是非抢占式调度，另一部分调度发生的是第二种方案的伪抢占式调度，第三种方案的信号抢占式调度很少，大部分系统根本不会被触发。这也是为什么到go 1.14才有第三种方案的协程调度。

这里有许多细节没有描述，大家可以再想一想：
1. 信号是发送给进程的，如何让一个指定的线程收到信号呢？
2. 信号处理程序是在线程从内核态切换会用户态时调用的，可以再细想一下协程抢占式调度的工作流。

## 协程问题探讨

我们通过四个go案例来一窥go的协程机制。

### 案例一
启动两个roroutine，可以正确调度
这是一个正常的case，这两个routine可能会被GMP调度在不同的线程上运行。

```
func TestSchedule1(t *testing.T) {
	go func() {
		for true {
			fmt.Printf("BBB\n")
			time.Sleep(1 * time.Second)
		}
	}()
	for true {
		fmt.Printf("AAA\n")
		time.Sleep(1 * time.Second)
	}
}
```

### 案例二

限制启动一个线程，那么这两个routine只能被GMP调度在同一个线程上运行。
sleep和printf是函数调用，可以做伪抢占式调度，上面的二个方案可以实现，这两个routine都可以被调度执行

```
func TestSchedule2(t *testing.T) {
	runtime.GOMAXPROCS(1)
	go func() {
		for true {
			fmt.Printf("BBB\n")
			time.Sleep(1 * time.Second)
		}
	}()
	for true {
		fmt.Printf("AAA\n")
		time.Sleep(1 * time.Second)
	}
}
```

案例三

限制启动一个线程，那么这两个routine只能被GMP调度在同一个线程上运行。
没有函数调用情况下，用户态的协程只能在抢占式调度下被切换，上面的第三个方式可以实现，这两个routine照样可以被调度执行。
只有go 1.14有信号实现的抢占式调度，所以以下代码在go 1.14在，两个routine可以被调度，会panic，而go 1.13和之前版本没有信号实现的抢占式调度，不会panic。

```
func TestSchedule3(t *testing.T) {
	runtime.GOMAXPROCS(1)
	go func() {
		panic("Can not here?")
	}()
	for true {
		continue
	}
}
```

案例四

启动二个线程，那么这两个routine可能会被GMP调度在二个线程上运行。
没有函数调用情况下，没有抢占式调度的情况下，这两个routine可以执行，因为他们可以被分配在两个线程上运行，线程调度是操作系统完成的，有抢占式调度机制的。
以下代码在go 1.13下也会panic

```
func TestSchedule4(t *testing.T) {
	runtime.GOMAXPROCS(1)
	go func() {
		panic("Can not here?")
	}()
	for true {
		continue
	}
}
```